<pre>

快速排序是冒泡排序的一种改进：通过比较数组元素与参照元素的大小关系，不断递归切割数组，最后再将数组切片组合成完整的有序数组

再次拿麻将打比方：

从乱序的牌中随便选一张作为参照物，一般是第一张，然后看第二张比这张是大还是小，如果大就放在右手边，如果小就放在左手边，直到全部比完，牌堆会被分成三部分：
小于参照物的arr1 、位于中间的参照牌、 大于参照物的arr2，此时，中间参照牌的位置必然正确

接着，重复上面步骤，选参照牌，将arr1切成3部分，不断重复直到三个部分都只剩一张牌，此时arr1就排序完成，arr2同理，最后，我们把所有的部分放到一起，就是拍完序的数组了。

注意：快速排序不是稳定排序算法，即相同的值排序后位置可能发生改变

由于每次递归调用了两次quick_sort函数，资源消耗会非常大，但是速度也快一些

<?php

$arr = [2, 6, 1, 7, 3, 8, 9, 4];

function quick_sort($arr)
{
  $len = count($arr);
  // 递归出口：数组长度为1或0（如果没有比参照物大或小的元素，，也可能为0）
  if ($len <= 1) return $arr;

  // 取出一个元素（一般是arr[0]比较方便），循环与之比较，切割成大小两个部分
  // 需要单独初始化大小2个数组（防止切割后某一边没有元素，small/big[]赋值语句没有执行，导致下面合并数组报错）
  $small = $big = [];
  for ($i = 1; $i < $len; $i++) {
    if ($arr[$i] < $arr[0]) {
      $small[] = $arr[$i];
    } else {
      $big[] = $arr[$i];
    }
  }
  // 切割完之后，合并数组，调用递归
  /**
   * array_merge(arr,arr[,...arr]) 可以将多个数组合并成一个
   * 由于$arr[0]不是数组，所以加中括号转化成数组
   * 复习下转化方式：
   * 1: array($arr[0]) 重新声明数组
   * 2:(array)$arr[0]  强制转换
   */

  // 这是合并切割一次的，也就是让第一个元素位于中间位置，此时$small和$big还没有排好序，这里是递归点
  // return array_merge($small, (array)$arr[0], $big);
  // 递归点：每次调用两次递归函数，速度很快，同时资源占用也大
  $small = quick_sort($small);
  $big = quick_sort($big);

  return array_merge($small, (array)$arr[0], $big);
}
print_r(quick_sort($arr));
