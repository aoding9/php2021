#  一 字段类型

## 1 字段类型的作用

字段类型的作用：mysql中用来规范数据格式
- 字段类型在定义表结构时设定
- 设定好字段类型后，插入数据要和他对应，否则数据错误
- 四大类型：
  - 整数：常用，tinyint int
  - 小数:常用，decimal float
  - 字符串 :常用，char varchar text
  - 时间日期 ：不常用，通常使用真正的时间戳存储数据，然后php进行灵活解读
- 实际开发时，要根据需求先判断好业务需要哪种数据类型
- 要考虑数据最大的边界，要具有数据通用性（一般选中类型）
- 用最小的消耗解决问题（如果数据不是很大，可以选空间占用更小的）



```sql
-- 错误插入：往int字段插入字符串

insert into db1(id) values('hh');
ERROR 1366 (HY000): Incorrect integer value: 'hh' for column 'id' at row 1
```



## 2 整数类型

**整数类型：** 存放有效的整数数据

- 迷你整型：tinyint 使用 **1个字节**存储，最多存256个整数  无符号：[0,2^8^]  有符号：[-2^7^,2^7^-1]
  
- 存放百级以内的数据，年龄这种
  
- 短整型：smallint 使用 **2个字节**存储，最多2^16^ （65536）
  
- 存放千级以内的数据
  
- 中整型：mediumint 使用 **3个字节**存储 2^24^（16 777 216）
  
- 存放千万以内的数据，无符号可以存一亿以内
  
- 标准整型：int 使用 **4个字节**存储  -2147483648~2147483647  [-2^31^~2^31^-1]
  
- 
  
- 大整型：bigint 使用 **8个字节**存储

  

**数值型存储，在mysql中分为有符号（有负数）和无符号（没有负数），有符号的数，存储的上限减半，用于存储负值**



### 步骤

- 确定数据的格式是存储整数
- 预估整数范围，选择合适类型（现在磁盘空间都比较大了，所以tinyint和int用的比较多，不用太计较一两个字节
- 确定整数是否需要符号（数据是否可能存在负数）



### 实例

1.设计一个表，记录人的年龄和头发数量

```sql
-- 年龄：整数，不超过200，没有负数 >> 迷你整型无符号
-- 头发数量：整数，大约几百万根，没有负数 >> 标准整型无符号
create table t_7(
	age tinyint unsigned,
    haircount int unsigned
)charset utf8;
```



2.设计一个表记录某4s店汽车销售信息，包括：库存数量，销量，采购量

```sql
/*
库存：可能先卖再进货，可能为负数，一个店库存不会太多 >> 小整型有符号
销量：全国也就几万台，且不会为负数，为了防止销量突然暴涨，虽然小整型也够，但采用中整型无符号
采购量：通常和销量差不多，中整型无符号
*/
create table t_8(
	stock smallint,
    sales mediumint unsigned,
    purchase mediumint unsigned
)charset utf8;
```





## 3 显示宽度

**显示宽度**: 整数在数据库中显示的符号（数字+符号）个数

在创建字段时有一个int(10) 这个10就是显示宽度，通过zerofill，可以让不够宽度的数据，在前面补0.

注意点：

- 一般是类型能表示的最大值的数字个数
- 包含符号，若允许为负，则-号也占一位
- 显示宽度可以主动控制
- 显示宽度不影响实际数值，int(10)和int(1)对于数据都是一样的，只影响显示
- 一般mysql关闭了自动补0，需要开启zerofill来自动填充0

**zerofill**：开启0填充，默认要求整型为无符号，如果设了zerofill，数据会自动转为无符号

- 通常用于制作一些规范宽度的数据



### 实例

1.有符号和无符号对应的宽度不一样，都是tinyint 有符号的有3位宽度，没符号的有4位宽度

```sql
create table t_9(
	a tinyint,
    b tinyint unsigned
)charset utf8;
desc t_9;
```



2.如何主动控制显示宽度

```sql
alter table t_9 add c tinyint(2) unsigned;
```



3.显示宽度不影响数据实际大小

```sql
insert into t_9 values(1,1,1); -- 小于显示宽度
insert into t_9 values(100,100,100); -- 大于显示宽度
```



4.要通过zerofill让小于显示宽度的数值 前面补0

```sql
alter table t_9 add d tinyint(2) zerofill;
insert into t_9 values(1,1,1,1);
/* select * from t_9;
+------+------+------+------+
| a    | b    | c    | d    |
+------+------+------+------+
|    1 |    1 | NULL | NULL |
|    1 |    1 |    1 | NULL |
|  100 |  100 |  100 | NULL |
|    1 |    1 |    1 |   01 |
+------+------+------+------+
*/
```



## 4 小数类型

### 浮点型

**浮点数：**float/double存储精度要求不高的数值数据

- 浮点数又称为精度数据
  - 单精度：float,使用**4个字节**存储，精度范围为6-7位
  - 双精度：double，使用**8个**字节存储，精度范围为14-15位
- 浮点数超过精度范围会自动四舍五入
- 精度可以指定整数和小数部分
  - 不指定时，默认整数部分不超过浮点数最大值，小数部分保留2位
  - 可指定，float/double(总长度,小数部分长度)
- 可以使用科学计数法插入数据



#### 步骤

1 确定当前设计的字段的数据为不精确型数据或小数

2 确定数据的大小或精度的范围

- 6-7位用float
- 14-15用double

3 确定精度的分布：整数部分和小数部分



#### 实例

1 记录宇宙中恒星数量、行星数量

```sql
-- 精确数量不清楚，只有个大概，采用float就够了
create table t_10(
	h_star float unsigned,
    x_star float(20,0) unsigned  -- 小数部分指定为0位，四舍五入了
);
insert into t_10 values(1234567890,1.2E10);  -- 科学计数法 1.2*2^10
/*
+------------+-------------+
| h_star     | x_star      |
+------------+-------------+
| 1234570000 | 12000000000 |
+------------+-------------+
可以看到12345是对的，但后面变成了70000，为什么？
只保留到第六位，7四舍五入到6，所以6变成7，后面的舍弃
*/
```



2 记录商品价格

```sql
-- 商品价格一般带2位小数
create table t_11(
	goods_name varchar(20),
    goods_price float
);
insert into t_11 values('abc',199.99); -- 此处没指定，小数默认保留2位
insert into t_11 values('def',1999.9999); -- 超出范围，四舍五入，不断进位变成2000，小数部分也没有了

/*
+------------+-------------+
| goods_name | goods_price |
+------------+-------------+
| abc        |      199.99 |
| def        |        2000 |
+------------+-------------+
*/
```



### 定点型

**定点型**：decimal 用于存需要保证精度的小数

- 不固定存储空间
- 每9个数字使用4个字节存储
- 定点型可以指定整数部分和小数部分的长度
  - 默认不指定，10位有效整数，0位小数
  - 指定，decimal(有效位数，小数部分位数)
  - 有效位数不超过65
- 数据规范
  - 整数部分超出指定范围会报错
  - 小数部分超出则四舍五入
- 定点型的数据越大，占用空间越多

#### 实例

记录个人资产和负债情况

```sql
-- 资产和负债都是精确的，小数部分保留2位，负债可能为负数
create table t_12(
	money decimal(14,2),   -- 十亿以下呃呃
	bet decimal(10,2) -- 整数部分10-2=8 也就是千万以下
);
insert into t_12 values(11111111.12,11111111.999); -- 小数部分超出，四舍五入
select * from t_12;
-- | 11111111.12 | 1111112.00 |
insert into t_12 values(11111111.12,111111111.999); -- 报错了，整数部分超出
/*
mysql> insert into t_12 values(11111111.12,111111111.999);
ERROR 1264 (22003): Out of range value for column 'bet' at row 1
*/
```





## 5 字符串类型

### 定长型

**定长型：** char(length) 指定固定字符长度的字符串

- 注意是字符不是字节

- length最大值为255

- 实际存储空间=length*字符集单字符对应字节数

- 定长型存储不可超过length，但可以小于

- 字符串数据用单或双引号包裹

- 定长型访问效率较高，但空间利用率不高，如果小于length，仍会占用length对应的空间

  

#### 步骤

1 确定数据类型为字符串（或者不能用整数存储的超长数字符号）

2 确定数据长度基本一致（定长）

3 确定具体长度多少



#### 实例

记录个人的身份证和手机号

```sql
-- 身份证为固定18位数字
-- 手机号是11位数字
create table t_13(
	id_number char(18),
    phone_number char(11)
);
insert into t_13 values('123456789012345678','12345678901'); -- 引号包裹
select * from t_13;
```



### 变长型



**变长型**：varchar(L) 根据实际存储的数据来分配存储空间

- 变长型的字符串越长，存储空间占用越大
- 变长型的L是指字符长度，不是字节
- L理论最大可为65535（实际没有）
- 变长型需要额外产生1-2字节，用于记录数据长度
  - 数据长度小于256，产生额外1字节
  - 大于256，额外产生2字节
- 实际存储空间= 实际字符数*字符集单字符字节数+记录长度
- 变长数据字符长度不能超过定义的L
- 变长型读取时需要进行长度计算，效率没有定长高



#### 实例

记录个人信息：用户名、密码、姓名、身份证

```sql
/*
用户名 不确定长度，最长50个字符
密码 不确定长度 最长15字符
姓名 不确定长度 最长10个字符
身份证 固定18字符
*/
create table t_14(
	username varchar(50),
    password varchar(15),
    name varchar(10),
    id_number char(18)
);
insert into t_14 values('xiaobai','123456','小明','123456789012345678');
select * from t_14;

/*
+----------+----------+------+--------------------+
| username | password | name | id_number          |
+----------+----------+------+--------------------+
| xiaobai  | 123456   | 小明 | 123456789012345678 |
+----------+----------+------+--------------------+
*/
```



### 文本字符串

**文本字符串：**text/blob 专门存储较长的文本

- text 普通字符
  - tinytext 迷你文本 不超过 **2^8^-1**个字符  255个
  - text 普通文本 不超过 **2^16^-1**  65535个
  - mediumtext 中型文本 不超过 **2^24^-1** 
  - longtext 长文本 不超过 **2^32^-1**  即4GB
- blob 二进制字符（类似于text）
  - tinyblob
  - blob
  - mediumblob
  - longblob
- 文本字符串会自动根据长度选择合适的类型，不用手动指定
- 什么时候选择文本字符串：一般超过255个字符就用text
- blob用的比较少
- text的效率比varchar低，能用varchar就尽量别用text



#### 步骤

1 确定类型为文本字符串

2 确定数据长度可能超过255

3 确定使用text



#### 实例

记录新闻的标题、作者、内容

```sql
-- 标题不超过50字符 varchar
-- 作者不超过10字符 varchar
-- 内容很长 text
create table t_15(
	title varchar(50),
    author varchar(10),
    content text
);
insert into t_15 values('震惊，打碎的鸡蛋不要扔','uc小编','打碎的鸡蛋不要扔，究竟是怎么一回事呢？原来是有一个外国小伙，打碎了鸡蛋没有扔，后来就发霉了。打碎的鸡蛋不要扔就是这么回事，欢迎在评论区留言。');
select * from t_15\G
```





### 枚举

**枚举类型：**enum 是一种映射存储方式，以较小的空间存储较多的数据

- 在定义时，枚举出可能的值
- 在定义以后，每次只能存储一个定义中出现的值，类似于单选
- 枚举使用1-2字节存储，最多存65535个选项
- 实际存储的是数值，读取时映射到对应的元素数据，从1开始
- 语法：enum(元素1,元素2,...)
- 作用：规范数据模型
- 优化存储空间



#### 步骤

1 确定数据的值是固定的那几个（最多65535）

2 穷举出相应元素

3 存储数据是单选，一条记录只能存其中之一



#### 实例

1 记录人群类型：儿童、少年、青年、中年、老年

```sql
create table t_16(
	type enum('儿童','少年','青年','中年','老年')
);
insert into t_16 values('少年'); -- ok
insert into t_16 values('奥特曼'); -- 错误，不存在这个，可以保证数据插入的安全
-- ERROR 1265 (01000): Data truncated for column 'type' at row 1
insert into t_16 values('少年','青年'); -- 错误
-- ERROR 1136 (21S01): Column count doesn't match value count at row 1
```



2 enum是建立映射关系，实际存储的是数字，元素从1开始

```sql
-- type+0表示将查出的type字段的值全部+0，显示成一个新的列，由于少年是2,2+0还是2
select type,type + 0 from t_16;
/*
+------+----------+
| type | type + 0 |
+------+----------+
| 少年 |        2 |
+------+----------+
*/

-- 如果直接往枚举类型的字段存1，可以读取到1对应的映射值
insert into t_16 values(1);
select * from t_16;
/*
+------+
| type |
+------+
| 少年 |
| 儿童 |
+------+
*/

```



#### 原理

建立key和value一一对应的关系，然后根据这个关系进行存储和读取。

存储过程：

```mermaid
graph LR
A(指令开始)-->B[插入数据]
B-->C(读取映射关系 元素对应数值 数值还是数值)
C-->D[数值存储到字段]
D-->E(结束)
```





### 集合



**集合：** set，也是一种映射，类似枚举，但是可以多选

和枚举不同之处：

- 可以存多个，类似多选
- 集合使用1-8个字节存储数据，最多存储64个元素（每个位表示一个元素）
- 实际是用二进制的0表示数据不存在，1表示存在 ，通过0和1建立映射
- 集合语法：set(元素1,元素2，...
- 作用：
  - 规范数据模型，数据安全
  - 优化存储空间

#### 步骤

1. 确定数据时固定的几种数据组合
2. 使用集合穷举相应的元素
3. 数据存储只能存穷举集合中的元素（使用逗号分隔）



#### 实例

1 记录个人爱好：有篮球、足球、乒乓球、排球

```sql
# 爱好可以有多个 但是只能从规定的种类里选
create table t_17(
	hobby set('足球','篮球','乒乓球','排球')
);
insert into t_17 values('足球');
insert into t_17 values('足球,篮球,排球');
select * from t_17;
/*
+----------------+
| hobby          |
+----------------+
| 足球           |
| 足球,篮球,排球 |
+----------------+
*/
```



2 集合也是映射的数值，但是是二进制数值

```sql
# 通过字段+0的方式查看存储的具体数值
select hobby,hobby + 0 from t_17;
/*
足球对应第一位，也就是0001
足球、篮球、排球，表示123位都是1，其余为0，即0111，转成十进制就是11
+----------------+-----------+
| hobby          | hobby + 0 |
+----------------+-----------+
| 足球           |         1 |
| 足球,篮球,排球  |        11 |
+----------------+-----------+
*/

# 可以通过插入数值来组合元素，但是需要确定对应的十进制转成二进制有对应的元素
insert into t_17 values(3);
/*
3转成二进制：0011 对应的就是足球和篮球
*/
select * from t_17;
/*
+----------------+
| hobby          |
+----------------+
| 足球           |
| 足球,篮球,排球 |
| 足球,篮球      |
+----------------+
*/
```





## 6 时间日期类型

### 年

**年：** year mysql中用于存储年份

- mysql中用1个字节存储
- year范围为1901-2155年（即256年）
- 特殊值是0000年
- year允许用户使用两种方式（效果一样）
  - year 普通
  - year(4)
  - year(2) 老版本使用2位的，但是mysql8不支持

- 由于范围有限，实际中通常会用字符串来存储

  

#### 步骤

1. 确定存的是年份
2. 确定年份在1901-2155
3. 可以使用year



#### 实例

1.记录出生年份

```sql
create table t_18(
	y1 year,
  y2 year(4)
);
insert into t_18 values(1901,2155);
select * from t_18;
/*
+------+------+
| y1   | y2   |
+------+------+
| 1901 | 2155 |
+------+------+
*/
```



2 year类型允许用2位数来插入，系统自动匹配对应年份

- 69以前，系统加上2000
- 69以后，系统加上1900

```sql
insert into t_18 values(69,70);
select * from t_18;
-- | 2069 | 1970 |
```



3 year类型特殊值0000，可以用00或0000插入，用的比较少

```sql
insert into t_18 values(00,0000);
select * from t_18;
-- | 0000 | 0000 |
```



### 时间戳



#### 概念

**时间戳：** timestamp 基于格林威治时间的时间记录

- mysql中的时间戳表现形式不是秒数，而是年月日时分秒格式
  - YYYY-MM-DD HH:II:SS
  - YYYYMMDDHHIISS

- timestamp使用4个字节存储，范围为1971-1-1 0:0:0到2155-12-31 23:59:59
- 特殊值：0000-00-00 00:00:00
- timestamp特点：当有字段值更新时，所在行的时间戳也会更新到当前时间
- 注意：旧版是默认自动更新，但mysql8以后取消了timestamp的默认自动更新，需要使用额外属性**current_timestamp**



#### 步骤

1. 确定类型要使用年月日时分秒格式
2. 确定当前字段需要记录数据的最近更新时间（比如记录用户最后一次登录时间等）
3. 可以使用timestamp



#### 实例

1 记录商品库存的最后更新时间

```
create table t_19(
	goods_name varchar(10),
	goods_inventory int unsigned,
	update_time timestamp
);
insert into t_19 values('西瓜',100,'2021-1-11 0:0:0');
insert into t_19 values('苹果',100,'20211101000000');
select * from t_19;
/*
+------------+-----------------+---------------------+
| goods_name | goods_inventory | update_time         |
+------------+-----------------+---------------------+
| 西瓜       |             100 | 2021-01-11 00:00:00 |
| 苹果       |             100 | 2021-11-01 00:00:00 |
+------------+-----------------+---------------------+
*/


```



2 自己所在记录的任何位置被修改，会自动更新时间（mysql8以后需要加额外属性**current_timestamp**）

```sql
alter table t_19 add c_time timestamp on update current_timestamp;
update t_19 set goods_inventory = 190 where goods_name = '西瓜';
select * from t_19;
/* 自动更新时间戳
+------------+-----------------+---------------------+---------------------+
| goods_name | goods_inventory | update_time         | c_time              |
+------------+-----------------+---------------------+---------------------+
| 西瓜       |             190 | 2021-01-11 00:00:00 | 2021-01-11 17:38:21 |
| 苹果       |             100 | 2021-11-01 00:00:00 | NULL                |
+------------+-----------------+---------------------+---------------------+
*/
```



### 日期

### 日期时间

### 时间

# 二 属性

## 属性的作用
## NULL属性
## Default属性
## 主键