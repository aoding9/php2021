# 范式

#### 概念

**范式** normal format ，符合某种级别的关系模式的集合，表示一个关系内部各属性之间的联系合理化程度

- 范式是离散数学里的概念

- 范式目标是在满足组织和存储的前提下，使数据结构冗余最小化

- 范式级别越高，表的级别就越标准

- mysql数据库主要用到前三层

  - 第一、二、三范式：1NF、2NF、3NF
  - 逆规范化

  

#### 实例

1、员工表范式优化 

| 工号 | 姓名 | 部门   | 入职时间   |
| ---- | ---- | ------ | ---------- |
| 0001 | 小明 | 宣传部 | 2021-01-01 |
| 0002 | 小白 | 文化部 | 2020-01-01 |
| 0003 | 小李 | 宣传部 | 2020-01-01 |

观察后发现，表中重复出现了宣传部，并且后面新增可能重复，占用了不必要的空间，应该把部门单独放到一张表

| 工号 | 姓名 | 部门编号 | 入职时间   |
| ---- | ---- | -------- | ---------- |
| 0001 | 小明 | 1        | 2021-01-01 |
| 0002 | 小白 | 2        | 2020-01-01 |
| 0003 | 小李 | 1        | 2020-01-01 |

| 部门编号 | 部门   |
| -------- | ------ |
| 1        | 宣传部 |
| 2        | 文化部 |



#### 小结

- 范式是一种数学理论，在关系型数据库中用于减少数据冗余
- 满足的范式越多，越符合高标准
- 范式一共6层，数据库设计满足前三层即可





## 第一范式 1NF

#### 概念

**1NF** 数据字段设计时必须满足原子性

- 指字段数据使用时可以不需要拆分处理即可使用
- 如果使用时需要拆分就违背1NF



#### 步骤

1. 设计的字段在使用时是否需要拆分
2. 在设计时就把字段拆分成使用时需要的最小单位
3. 满足1NF



#### 实例

 优化设计学生成绩表满足1NF：业务要求显示开始时间或结束时间（如果业务不要求拆分，可以看做满足1NF）

| 学生 | 性别 | 课程 | 教室 | 成绩 | 学习时间 |
| ---- | ---- | ---- | ---- | ---- | -------- |
| 张三 | 男   | php  | 101  | 100  | 2-1~2-28 |
| 李四 | 女   | java | 102  | 90   | 3-1~3-31 |
| 张三 | 男   | java | 102  | 95   | 3-1~3-31 |

发现：学习时间是一个时间段，那么就需要拆分，即不满足1NF

满足1NF的设计：字段颗粒度应用层最小

| 学生 | 性别 | 课程 | 教室 | 成绩 | 开始时间 | 结束时间 |
| ---- | ---- | ---- | ---- | ---- | -------- | -------- |
| 张三 | 男   | php  | 101  | 100  | 2-1      | 2-28     |
| 李四 | 女   | java | 102  | 90   | 3-1      | 3-31     |
| 张三 | 男   | java | 102  | 95   | 3-1      | 3-31     |



#### 小结

- 1NF要保证字段数据颗粒度最小，应用层不需要再拆分
- 1NF是满足数据表设计的最基础规范



### 第二范式 2NF

#### 概念

**2NF：** 字段设计不能存在部分依赖

- 指表存在复合主键时，有的字段只依赖复合主键中的一部分字段，而不是全部
- 如：栏目id和文章aid组成复合主键，但是有个字段文章标题title只依赖aid，而不依赖栏目id，此时就违反了2NF
- 解决方法：
  -  1：取消复合主键，改用逻辑主键（本质上还是部分依赖，只不过改了索引的字段）
  - 2：（推荐）将部分依赖独立成表

#### 步骤

1. 表中是否存在复合主键
2. 其他字段是否存在依赖主键中的一部分
3. 将存在的部分依赖关系独立成表
4. 满足2NF



#### 实例

优化学生成绩表满足2NF：

| 学生 | 性别 | 课程 | 教室 | 成绩 | 开始时间 | 结束时间 |
| ---- | ---- | ---- | ---- | ---- | -------- | -------- |
| 张三 | 男   | php  | 101  | 100  | 2-1      | 2-28     |
| 李四 | 女   | java | 102  | 90   | 3-1      | 3-31     |
| 张三 | 男   | java | 102  | 95   | 3-1      | 3-31     |

- 学生和课程起决定性关系，是主属性
- 成绩由学生和课程决定，满足2NF
- 性别由学生决定，不由课程决定，不满足2NF
- 教室、开始/结束时间由课程决定，不由学生决定，不满足2NF
- 一共存在3种不同的主属性依赖，所以需要建立3张表



**2NF设计方案：**

**1 学生表**

| stu_id（P） | 姓名 | 性别 |
| ----------- | ---- | ---- |
| 1           | 张三 | 男   |
| 2           | 李四 | 女   |

- stu_id是姓名的指代属性，即逻辑主键，本质是姓名
- 姓名只依赖姓名
- 

**2 课程表**

| class_id(P) | 教室 | 教室 | 开始时间 | 结束时间 |
| ----------- | ---- | ---- | -------- | -------- |
| 1           | php  | 101  | 2-1      | 2-28     |
| 2           | java | 102  | 3-1      | 3-31     |

- class_id是课程指代属性，逻辑主键
- 其他属性都只依赖课程



**3 成绩表**

| stu_id(P) | class_id(P) | 成绩 |
| --------- | ----------- | ---- |
| 1         | 1           | 100  |
| 2         | 2           | 90   |
| 1         | 2           | 95   |

- stu_id和class_id共同组成主属性，复合主键

- 成绩依赖学生和课程

  

至此，所有字段满足2NF



#### 小结

1. 2NF实在满足1NF 的基础之上的
2. 目标是取消表中存在的部分依赖
   - 主键为复合主键才可能存在
   - 通过让部分依赖独立成表来解决
3. 可以很大程度地减少数据冗余



## 第三范式 3NF

#### 概念

**3NF** ： 字段设计不能存在传递依赖

- 传递依赖，指某个非主属性字段A，通过依赖其他非主属性字段B，间接依赖主属性C（A依赖B，B依赖C）
- 解决办法：把间接依赖独立成表，即A依赖B，那么他们俩单独做一个表即可