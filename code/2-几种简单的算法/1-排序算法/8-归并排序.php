<pre>
归并排序（merge-sort）是建立在归并操作上的一种有效的排序算法，是采用分治法(divide and conquer)的一个非常典型的应用。
将已有的子序列合并，得到完整的有序的序列，即先使每个子序列有序，再使子序列段之间也有序。若将两个有序表合并成一个有序表，称为二路归并

继续拿麻将打比方：
我左右手各有两个排好序的麻将堆，第一步：两边各取出一个麻将（不是真取出，只查询他们的值），比大小，如果谁比较小，就把他拿出来，放到第三个牌堆

然后两边再各取一个比大小，小的就放0，其他后移，重复直到某一个牌堆摸完，此时其中一个牌堆为0，另两个个牌堆是已经拍好序，而且新牌堆肯定比旧牌堆元素小，再合并牌堆即可

问题是：如何得到两个有序数组？

完整步骤：
1 将数组拆分成2个数组
2 重复1，将数组拆成最小单元
3 申请空间，其大小为两个已排序序列之和，用于存放合并后序列
4 设定2个指针，初始位置为已排序序列的起始位置
5 比较2个指针指向的元素，选择较小的放入合并空间，并移动指针到下一位置
6 重复3，直到某一个指针超出序列尾部
7 将另一序列剩下的所有元素复制到合并序列尾部
<?php
// 二路归并
$arr1 = [1, 3, 5];
$arr2 = [2, 4, 6];

// 第三个数组用于归并空间
$arr3 = [];

// 只要arr1和arr2都有元素，就比较
while (count($arr1) && count($arr2)) {
  // 把arr1和2中第0个元素比较，小的那个取出来放到arr3
  $arr3[] = $arr1[0] < $arr2[0] ? array_shift($arr1) : array_shift($arr2);
}

// 合并，$arr3是最小的，1和2其中一个是空数组，所以可以直接都合并
// print_r(array_merge($arr3,$arr1,$arr2));




// 归并排序函数
$arr = [2, 6, 1, 7, 3, 8, 9, 4];

function merge_sort($arr)
{
  $len = count($arr);
  // 递归出口：如果数组长度为1，说明已经拆分为最小序列了，也就是最小的有序序列，可以开始回溯
  if ($len <= 1) return $arr;

  // 从中间拆分，向下取整
  $middle = floor($len / 2);
  // 用slice函数截取
  $left = array_slice($arr, 0, $middle);  // 0到middle
  $right = array_slice($arr, $middle); // 从middle取到最后

  // 递归点：left和right都没排好序，在归并之前需要排列为有序序列，可以用相同办法切割排序\
  // 二路归并和快速排序速度差不多的，都是每次调用2个递归函数，但是如果用三路归并、四路归并，就会更快
  $left = merge_sort($left);
  $right = merge_sort($right);

  // 上面用递归拍好序，下面开始合并有序的序列段
  // 声明第三个数组用于归并空间，由于php数组没有长度限制，所以不用计算长度
  $small = [];
  while (count($left) && count($right)) {
    // 把arr1和2中第0个元素比较，小的那个取出来放到arr3
    $small[] = $left[0] < $right[0] ? array_shift($left) : array_shift($right);
  }
  return array_merge($small, $left, $right);
}
print_r(merge_sort($arr));
