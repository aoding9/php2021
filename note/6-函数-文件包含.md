## 1 文件包含

https://blog.csdn.net/qq_36324472/article/details/110133609

### 1.1 是啥

在一个php脚本文件中包含另一个php文件

### 1.2 有啥用

- 向上包含（把朋友的东西给自己用）：使用被包含文件中的内容，比如变量、函数等等，实现代码复用，一般在上面引用，叫向上包含

- 向下包含（把自己的东西给朋友用）：将自己的变量函数等等，分析给被包含的文件，，一般在下面引用，叫向下包含
- 分工协作，利于维护和阅读



### 1.3 怎么用

包含两大种，4小种

- include 
- include_once
- require
- require_once



带有once的，系统会自动判断是否已经包含过，不重复包含

```php
<?php
// 向上包含，使用上面包含文件中的内容
  include '1-aa.php';
  // 另一种写法
  // include(文件路径)
  echo $a;
$b = 2;
  // 向下包含，先把自己的内容给下面包含的文件使用
  require '1-bb.php';
  

  

  // include和require区别
  // include包含文件出错，错误级别为Warning，不影响后面继续执行
  include '1-cc.php';
  // require包含文件出错，错误级别为error，后面代码不会执行
  require '1-cc.php';

  // 不过我这个都是报的warning，可能是新版本或者配置不同导致的


```



#### 文件加载原理：

系统将被包含内容嵌入到包含关键字所在位置，类似于复制过来了（魔术常量例外，仍然是原来文件的信息）
但是和直接写一起有区别：被包含文件单独编译，加载到内存中

#### php代码执行过程：

- 读取php文件 

- php编译为字节码(opcode） 

- zend engine解析opcode，按照字节码进行逻辑运算 

- 转换为html代码



## 2 函数

### 2.1 是什么

函数function时一种语法结构，将实现某个功能的代码块封装到一个结构中，从而实现代码复用

### 2.1 作用

代码复用,一般一个功能一个函数，

### 2.2 语法

```php
function 函数名([参数]){
	函数体
    [return 返回值]
}
```

### 2.3 注意

```php
<?php
// 1.如果函数定义时有形参，那么调用时需要传实参
function aaa($a)
{

  echo $a;
  return __FUNCTION__; // 魔术常量，返回当前函数名
  echo 'return关键字除了返回值，还表示函数运行结束，下面的代码不会执行';
}
// 2.如果函数体（花括号中间这部分）定义了返回值，那么外面可以接收到，如果没有返回值，系统默认返回NULL
$b = aaa(1);

var_dump(aaa(1)); // 如果没有写返回值，默认返回NULL

echo $b;


  // 3.函数执行是在代码执行阶段，执行到函数调用的那一行才去内存中进行调用，不是在编译阶段，所以可以在函数定义之前写调用代码（因为已经编译好了）
```

### 2.4.函数命名规范



- 驼峰法  showInfo

- 下划线法 show_info

- 命名要有具体意义，尽量看名字就大概知道这个函数的功能，不要乱写，比如showInfo不要写成si等意义不明的东东

- 一个脚本周期中不能有两个同名函数



### 2.5 关于参数

- 作用：1.使用外部变量 2.动态地执行函数，根据不同参数，得到不同结果

- 形参：在函数定义时，并没有实际参数，所以用形参代替实参，在执行时用于接收实参
- 实参：函数执行时，实际参与运算的参数，运算之前系统会把实参赋值给形参
- 形参数量要小于等于实参，如果定义时有3个形参，但是执行只传了2个实参，会报错（没有默认值的情况下），但是实参数量可以大于形参，多出的实参不会导致报错

- 默认值：定义函数时给形参设置默认值，如果没有传对应的实参，那么会用默认值代替（一般用于实参值很大可能是这个，但是又可能会变化的情况）

### 2.6 执行过程

- 系统调用函数时，先去内存寻找是否有这个函数

- 系统在栈区开辟内存空间运行函数

- 先查看函数是否有形参

* 在判断调用时是否传了对应的实参

- 默认将实参赋值给形参

* 执行函数体

* 将函数返回值返回出去（如果有返回的话）

  

```php
// 多个参数
// 这里有2个形参
function addition($a, $b)
{
  return $a + $b;
}
// 只有传了1个实参，第二个实参没有实际值，导致报错
// echo addition(1);
// 这里有3个实参，第三个虽然没有形参接收，但此时有没有这个多余的参数都不会导致函数体出错
echo addition(1, 2, 3);
echo '<br>';

// 默认值
// 定义时就给形参初始值，调用时如果不传入，就会使用初始值，如果传实参，则会覆盖初始值
// 注意：默认值必须放在最右边，不能左边有右边没有，错误案例：function subtraction($a=1, $b)
function subtraction($a=1, $b=2)
{
  return $a - $b;
}

echo subtraction(2);
```

### 2.7 引用传递

通常情况，实参赋值给形参是简单值传递，即将实参的值复制一份，然后将复制的值赋值给形参，改变形参并不会影响实参

如果希望函数内部修改形参可以影响到实参，就可以用 ``&$变量名``，将实参的内存地址赋值给形参，二者会指向相同的内存地址，从而互相影响

- 引用传递时，&符后面必须是变量（不能是常量等）

### 2.8 函数体、return

{}之间的内容就是函数体，可以进行各种操作

通过return关键字给出返回值，将他返回到函数调用的位置

- return表示函数结束，后面的代码不会执行

- return在被包含文件中使用，可以将某些东东返回给声明文件包含的位置，同时被包含文件终止执行

### 2.9 作用域

作用域：变量、常量能够被访问的区域，能够起作用的区域

一般每个函数都有自己独立的局部作用域

- 全局变量：在最外面，用普通方式定义的变量，所属全局空间，php中只允许在全局空间使用，一般函数内部不可以访问，生命周期为脚本周期（脚本执行完才销毁）

- 局部变量：在函数体内定义的变量，默认作用域就是当前函数，只有当前函数内可以使用，函数外部无法访问，生命周期为函数周期（函数执行完就销毁，可以特别处理后保留）
- 超全局变量：系统定义的变量（预定义变量$\_SERVER $\_POST等）没有访问限制，哪里都可以用



### 2.10 global关键字

如果要让局部和全局都可以访问某个变量，除了使用超全局变量，以及参数引用传值之外，还可以通过global关键字

global关键字可以在函数内部声明变量，此变量如果在函数外有全局同名变量，则自动指向全局变量，如果没有同名的，则在外部自动声明一个同名全局变量，并且内外两个变量都是指向同一个内存空间。本质就是声明全局和局部同名变量，并且保存相同内存地址。

语法：global 变量名; 

- global声明时不能赋值

```php
$g = 1;
function g()
{
  global $g;
  $g = 3; // 这里修改g,外面也被修改了
  global $g2; //外面没有g2，自动声明一个全局g2
  $g2 = 2;
}
g();
echo $g;
echo '<br>';
echo $g2;

  // 一般不会这么用，而是用参数形式，或者常量（常量没有访问限制）
```



### 2.11 static静态变量

- 静态变量（static）：仅在在函数作用域内存在，当程序执行到离开作用域后，静态变量没有销毁，之后再进入该函数作用域时，可以继续使用上次执行后保留的值。
- 一般用于函数执行次数的统计，以及递归时，根据递归次数，执行不同代码。

```php
function count1()
{
  $i1 = 0;  // 普通局部变量，函数执行完销毁，相当于每次重新赋值为0
  echo $i1++;
  echo '-';
  static $i2 = 0;  // static静态变量，函数执行完没销毁，下次执行不会重新赋值，而是使用上次的值
  echo $i2++;
  echo '<br>';
}

echo '<hr>';
count1();
count1();
count1();
```

- 系统编译时就对static变量初始化赋值了，函数调用时，自动跳过static这一行，没有重新赋值

### 2.12 可变函数

类似可变变量，使用变量保存函数的名字，然后$变量();调用对应的函数。一般在回调函数里面用的比较多。

### 2.13 回调函数

可变函数一般用于回调函数，意思是函数执行到某一步，再去调用另外的函数，并且这个函数是作为参数传进去的

```php
// 可变函数

function add()
{
  echo 1 + 2;
}
// 用变量保存函数的名字
$myFunc = 'add';
// 然后调用
$myFunc();
echo '<hr>';


// 回调函数
// 一个函数内调用另一个函数，并且这个函数是通过参数传进来的可变函数。
function callBack($func1, $func2)
{
  // 使用callBack时，自动调用传进来的函数，由于代码顺序执行，当回调函数放在最前面或者最后时，就可以通过回调函数是否执行，判断外部函数执行到哪一行了。
  $a = $func1(); // func1一定会在func2前面执行，并且我们可以得到他的返回值，交给第二个回调函数去处理
  // 另外，定义时如果将局部变量传递给可变函数，那么回调函数内部就可以使用这个外部函数的变量了，从而对函数结果进行自定义的处理
  $b = 1;
  $result = $func2($a, $b);
  return $result;  // 返回结果
}
function start()
{
  echo '开始执行了<hr>';
  return 3;  // 返回3，交给回调函数处理
}
// 需要形参接收回调函数传过来的实参
function ended($a, $b)
{
  echo '结束执行了<hr>';
  return $a + $b;
}
$start = 'start';
$ended = 'ended';

// 传变量名进去，或者变量名保存给变量再传，或者用变量保存匿名函数，然后传变量也行
echo callBack('start','ended');
// echo callBack($start, $ended);
```

### 2.14 匿名函数、闭包

```php
<?php
// https://www.php.cn/php-ask-429876.html
// php闭包和js闭包有一些区别

// 匿名函数Anonymous functions：没有名字的函数，定义时要赋值给变量再去使用
$func = function () {
  echo '我是匿名函数<br>';
};  // 由于是赋值，所以结尾要分号

// 用可变函数调用匿名函数
$func();

// 变量保存匿名函数，本质得到一个Closure对象 （闭包对象）
var_dump($func);  // object(Closure)#1 (0) { }
echo '<br>';

/**
 * 匿名函数也叫闭包函数，当匿名函数赋值给变量时，php自动将表达式转换为closure类的实例对象
 * 作用：闭包可以保存上下文的一些变量和值，延长其生命周期
 * 特性：默认闭包不能从父作用域继承变量，一般通过use结构传递进去，默认是传clone的值，如果要完全引用，可以加&进行引用传值
 * 闭包一般理解：函数内部定义匿名函数，然后通过use关键字得到父作用域的变量，接着将匿名函数返回出去。当调用外部函数时，匿名函数被返回，虽然外部函数已经执行结束，但由于匿名函数等待调用，所以use的变量不会销毁。
 */
function out()
{
  $a = 123;
  // 通过use，将父级作用域的变量传入匿名函数内
  $closure = function () use ($a) {
    return $a;
  };
  // 将匿名函数返回出去
  return $closure;
}
// 将返回的匿名函数保存给变量，out虽然执行结束，但$a在等待匿名函数调用，没有销毁
$b = out();
echo $b();
```

